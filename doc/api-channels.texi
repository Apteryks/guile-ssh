@c -*-texinfo-*-
@c This file is part of Guile-SSH Reference Manual.
@c Copyright (C) 2014 Artyom V. Poptsov
@c See the file guile-ssh.texi for copying conditions.

@node Channels
@section Channels

@menu
* Channel Management::
* Port Forwarding::
* Tunnels::
@end menu

@node Channel Management
@subsection Channel Management

@cindex data transferring
@tindex channel

The @code{(ssh channel)} module provides facilities to create
Guile-SSH channels and manipulating of them.

Channels are implemented as GNU Guile ports.  Therefore they can be
used with regular I/O procedures such as @code{display}, @code{write},
@code{read-line} and friends (@pxref{Input and Output,,, guile, The
GNU Guile Reference Manual}).  This section describes operations that
are specific for the channels.

@deffn {Scheme Procedure} channel? x
Return @code{#t} if @var{x} is a Guile-SSH channel, @code{#f}
otherwise.
@end deffn

@deffn {Scheme Procedure} make-channel session
Allocate a new Guile-SSH channel for the @var{session}
(@pxref{Sessions}).
@end deffn

@deffn {Scheme Procedure} channel-open-session channel
Open a session channel.  This procedure actually turn the
@var{channel} into an open port available for I/O operations.  Throw
@code{guile-ssh-error} on error.  Return value is undefined.
@end deffn

@deffn {Scheme Procedure} channel-request-exec channel command
@cindex non-interactive SSH session
@cindex command execution
Run a shell @var{command} without an interactive shell.  The @var{channel}
must be open.  Throw @code{guile-ssh-error} on error.  Return value is
undefined.

@strong{Note} that the procedure only can be used to execute a single command
on the remote host, so you should close the channel after
@code{channel-request-exec}.  If you want to execute another command then you
must open a new channel and use it.

Example:

@lisp
(let ((channel (make-channel session)))
  (channel-open-session channel)
  (channel-request-exec channel "uname")
  (read-line channel))
@result{} "Linux"
@end lisp

@end deffn

@deffn {Scheme Procedure} channel-request-pty channel
Request a @acronym{PTY} (pseudo terminal).  Throw @code{guile-ssh-error} on
error.  The @var{channel} must be open.  Return value is undefined.
@end deffn

@deffn {Scheme Procedure} channel-request-shell channel
Request a shell.  The @var{channel} must be open.  Throw
@code{guile-ssh-error} on error.  Return value is undefined.
@end deffn

@deffn {Scheme Procedure} channel-request-env channel variable value
@cindex setting of environment variables
Set an environment @var{variable} to @var{value}.  Throw
@code{guile-ssh-error} on error.  The @var{channel} must be open.  Return
value is undefined.
@end deffn

@deffn {Scheme Procedure} channel-request-send-exit-status channel exit-status
Send an @var{exit-status} to the remote process (as described in RFC 4254,
section 6.10).  Only SSH-v2 is supported.  Return value is undefined.

The @var{channel} needs to be closed with after this message.
@end deffn

@deffn {Scheme Procedure} channel-set-pty-size! channel columns rows
Change size of the @acronym{PTY} to @var{columns} and @var{rows}.  The
@var{channel} must be open.  Return value is undefined.
@end deffn

@deffn {Scheme Procedure} channel-set-stream! channel stream
Set default @var{stream} for @var{channel}.  @var{stream} must be one of the
following symbols: @code{stdout} (default), @code{stderr}.  The @var{channel}
must be open.  Throw @code{guile-ssh-error} on error.  Return value is
undefined.

Example:

@lisp
(channel-set-stream! channel 'stderr)
@end lisp
@end deffn

@deffn {Scheme Procedure} channel-get-stream channel
Get current stream name from @var{channel}.  The @var{channel} must be open.
Throw @code{guile-ssh-error} on error.  Return one of the following symbols:
@code{stdout}, @code{stderr}.

Example:

@lisp
(channel-get-stream channel)
@result{} 'stderr
@end lisp
@end deffn

@deffn {Scheme Procedure} channel-get-session channel
Get the session to which belongs the @var{channel}.  Throw
@code{guile-ssh-error} on an error.  Return the session.
@end deffn

@deffn {Scheme Procedure} channel-eof? channel
Return @code{#t} if remote has sent @acronym{EOF}, @code{#f} otherwise.  Throw
@code{guile-ssh-error} if the channel has been closed and freed.
@end deffn

@deffn {Scheme Procedure} channel-get-exit-status channel
Get the exit status of the @var{channel} (error code from the executed
instruction).  The @var{channel} must be open.  Return the exist status, or
@code{#f} if no exit status has been returned (yet).  Throw
@code{guile-ssh-error} on error.
@end deffn

@node Port Forwarding
@subsection Port Forwarding

@cindex Port forwarding

Low-level API from @code{(ssh channel)} module to manage SSH port
forwarding. These procedures @strong{do not} bind the ports and do not
automatically forward the content of a socket to the channel.  You should
either implement binding and data forwarding in your application or use the
tunnel API (@pxref{Tunnels, Guile-SSH tunnel API})

@deffn {Scheme Procedure} channel-open-forward channel [#:source-host=''localhost''] #:local-port #:remote-host [#:remote-port=local-port]
Open a (local) TCP/IP forwarding @var{channel}.  Connect to a
@var{remote-host} and @var{remote-port}, and use @var{source-host} and
@var{local-port} as origination of connections.

The local port forwarding works as follows:

@example
local-host               remote-host
,...............,        ,.................
:               :        :                :
:  [a browser]  :        : [a web server] :
:       |       :        :        A       :
:       |       :        :        |       :
:   port 8080   :        :     port 80    :
:       |       :        :        |       :
:       V       :        :        |       :
:  [SSH client]===========>[SSH server]   :
:               :        :                :
'...............'        '................'
@end example

Where port 8080 is an arbitrary @var{local-port} and port 80 is a
@var{remote-port}.

Also in our case, ``SSH client'' is an application that uses Guile-SSH and
calls @code{channel-open-forward}.

Example:

@lisp
(channel-open-forward channel
                      #:local-port  8080
                      #:remote-host "www.example.org"
                      #:remote-port 80)
@end lisp
@end deffn

@deffn {Scheme Procedure} channel-open-forward/reverse channel [#:source-host=''localhost''] #:local-port #:remote-host [#:remote-port=local-port]
Open a TCP/IP reverse (remote) forwarding @var{channel}.  Connect to a
@var{remote-host} and port @var{remote-port} and forward connections on the
@var{remote-port} to a @var{source-host} and @var{local-port}.

Reverse port forwarding looks as follows:

@example
local-host                remote-host
,................,        ,.................
:                :        :                :
: [a web server] :        :  [a browser]   :
:        A       :        :       |        :
:        |       :        :       |        :
:     port 80    :        :   port 8080    :
:        |       :        :       |        :
:        |       :        :       V        :
:   [SSH client]===========>[SSH server]   :
:                :        :                :
'................'        '................'
@end example

@end deffn

@node Tunnels
@subsection Tunnels

@cindex Tunnels

The following procedures from @code{(ssh tunnel)} module are a high-level API
built upon the basic port forwarding facilities for managing port forwards.

@deffn {Scheme Procedure} make-tunnel session [#:source-host=''127.0.0.1''] #:local-port #:remote-host [#:remote-port=local-port]
Make a new SSH tunnel using @var{session} from @var{source-host} and @var{local-port} to a @var{remote-host} and @var{remote-port}.

Return a new tunnel object.
@end deffn

@deffn {Scheme Procedure} start-forward tunnel
Start port forwarding on @var{tunnel}.  The procedure actually binds tunnel
ports and forwards data.
@end deffn

@subsection Example

Here is a simple Guile program that connects to ``www.example.org'' and starts
port forwading from the local port 8080 to the port 80 on the remote host:

@lisp
#!/usr/bin/guile \
-e main
!#

(use-modules (ssh session)
             (ssh auth)
             (ssh key)
             (ssh tunnel))

(define (main args)
  (let ((s (make-session #:user          "alice"
                         #:host          "localhost"
                         #:port          22
                         #:log-verbosity 'nolog))
        (k (private-key-from-file "/home/alice/.ssh/id_rsa")))
    (connect! s)
    (userauth-public-key! s k)
    (let ((t (make-tunnel s
                          #:local-port  8080
                          #:remote-host "www.example.org"
                          #:remote-port 80)))
      (start-forward t))))
@end lisp

@c Local Variables:
@c TeX-master: "guile-ssh.texi"
@c End:
